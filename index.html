<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 核心：禁止缩放，适配刘海屏 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>DeepSpace: Nexus</title>
    <style>
        /* --- 0. 全局设置 --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; background: #020202; overflow: hidden; 
            /* 使用 Apple 系统字体，更贴合 Safari */
            font-family: -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif; 
            color: #fff; user-select: none;
        }
        canvas { display: block; }
        
        /* 关键：防止 iOS 视频全屏 */
        #input_video { 
            display: none; 
            position: absolute; top: 0; left: 0; 
        }

        /* --- 1. 入场动画 --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease; pointer-events: none;
        }
        #loader.done { opacity: 0; }
        .loader-text { 
            font-size: 14px; letter-spacing: 6px; margin-bottom: 20px; font-weight: 600;
            background: linear-gradient(135deg, #fff 0%, #aaddff 100%);
            -webkit-background-clip: text; color: transparent;
        }
        .loader-line { width: 120px; height: 1px; background: #222; position: relative; overflow: hidden; }
        .loader-fill { 
            position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: #fff; 
            transition: width 0.2s linear; box-shadow: 0 0 15px #fff;
        }

        /* --- 2. 菜单按钮 --- */
        #ui-layer { position: absolute; top: 30px; left: 30px; z-index: 1000; }
        
        #menu-btn {
            width: 44px; height: 44px; /* 加大触控区适配手指 */
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.4s ease;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        #menu-btn::after {
            content: ''; width: 6px; height: 6px; background: #fff; border-radius: 50%;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            transition: background 0.3s;
        }
        #menu-btn:active { transform: scale(0.9); }

        /* --- 3. 菜单面板 (高斯模糊+大圆角) --- */
        #menu-panel {
            position: absolute; top: -10px; left: -10px;
            width: 280px;
            /* 深度磨砂质感 */
            background: rgba(15, 15, 20, 0.75); 
            backdrop-filter: blur(50px); -webkit-backdrop-filter: blur(50px); /* 模糊度拉满 */
            border: 1px solid rgba(255, 255, 255, 0.12);
            /* 大圆角 */
            border-radius: 24px; 
            padding: 28px;
            
            transform-origin: 32px 32px; 
            transform: scale(0.4); opacity: 0; 
            pointer-events: none;
            
            /* iOS 风格的弹簧动画 */
            transition: 
                transform 0.6s cubic-bezier(0.19, 1, 0.22, 1),
                opacity 0.4s ease;
            
            box-shadow: 0 30px 60px rgba(0,0,0,0.5);
        }

        #ui-layer.active #menu-panel { transform: scale(1); opacity: 1; pointer-events: auto; }
        #ui-layer.active #menu-btn { opacity: 0; pointer-events: none; transform: scale(0.8); }

        /* --- 4. 菜单排版 --- */
        .header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 25px; padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        
        /* 彩色英文标题 */
        .title { 
            font-size: 14px; font-weight: 800; letter-spacing: 2px; 
            /* 渐变流光文字 */
            background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%);
            -webkit-background-clip: text; color: transparent;
            text-transform: uppercase;
            animation: hue-flow 8s infinite linear;
        }
        
        .close { font-size: 11px; color: rgba(255,255,255,0.4); cursor: pointer; padding: 4px; }
        .close:hover { color: #fff; }

        .row { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 12px; align-items: center; }
        .label { color: rgba(255,255,255,0.5); font-weight: 500; }
        .value { color: #ddd; font-family: "SF Mono", "Menlo", monospace; letter-spacing: -0.5px; } 
        
        .value.accent { color: #00ffaa; font-weight: 600; text-shadow: 0 0 12px rgba(0,255,170,0.4); } 
        .value.inactive { color: #557799; }

        .section-title { 
            font-size: 10px; color: rgba(255,255,255,0.3); margin-top: 24px; margin-bottom: 10px; 
            letter-spacing: 1px; text-transform: uppercase; font-weight: 700;
        }
        
        .guide-row { 
            display: flex; justify-content: space-between; margin-bottom: 8px; 
            font-size: 11px; color: rgba(255,255,255,0.6); 
        }

        @keyframes hue-flow { 0%{filter: hue-rotate(0deg);} 100%{filter: hue-rotate(360deg);} }
    </style>

    <!-- 基础库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- 载入层 -->
    <div id="loader">
        <div class="loader-text">NEXUS ENGINE</div>
        <div class="loader-line"><div class="loader-fill" id="load-bar"></div></div>
    </div>

    <!-- 交互 UI -->
    <div id="ui-layer">
        <div id="menu-btn" onclick="UI.toggle()"></div>
        
        <div id="menu-panel">
            <div class="header">
                <!-- 彩色英文标题 -->
                <span class="title">NEXUS CORE</span>
                <span class="close" onclick="UI.toggle()">CLOSE</span>
            </div>

            <div class="row">
                <span class="label">输入模式</span>
                <span class="value inactive" id="disp-source">TOUCH / MOUSE</span>
            </div>
            <div class="row">
                <span class="label">AI 节点</span>
                <span class="value" id="disp-net">AUTO SELECT...</span>
            </div>
            <div class="row">
                <span class="label">线路延迟</span>
                <span class="value" id="disp-ping">-- ms</span>
            </div>
            
            <div class="section-title">实时遥测</div>
            <div class="row">
                <span class="label">刷新率</span>
                <span class="value" id="disp-fps">-- Hz</span>
            </div>
            <div class="row">
                <span class="label">手势张力</span>
                <span class="value" id="disp-val">0.00</span>
            </div>

            <div class="section-title">操作指令</div>
            <div class="guide-row"><span>单指拖动</span> <span>旋转视界</span></div>
            <div class="guide-row"><span>握拳</span> <span>引力坍缩</span></div>
            <div class="guide-row"><span>张开手掌</span> <span>宇宙膨胀</span></div>
        </div>
    </div>

    <!-- 增加 playsinline 属性防止 iOS 全屏 -->
    <video id="input_video" playsinline muted autoplay></video>

    <!-- Shader 渲染核心 -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (400.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D tex;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4(vColor, 1.0) * texture2D(tex, gl_PointCoord);
            if (gl_FragColor.a < 0.05) discard;
        }
    </script>

    <script>
        // ================= 全局状态 =================
        const State = {
            hasHand: false,
            mRotX: 0, mRotY: 0, mZoom: 1, // 鼠标
            hRotX: 0, hRotY: 0, hZoom: 1, // 手势
            tRotX: 0, tRotY: 0, tZoom: 1  // 目标
        };

        const UI = {
            el: document.getElementById('ui-layer'),
            loader: document.getElementById('loader'),
            bar: document.getElementById('load-bar'),
            
            toggle: () => {
                document.getElementById('ui-layer').classList.toggle('active');
            },
            
            intro: () => {
                let p = 0;
                const t = setInterval(() => {
                    p += 2; UI.bar.style.width = p + '%';
                    if(p>=100) {
                        clearInterval(t);
                        setTimeout(() => UI.loader.classList.add('done'), 200);
                        Network.init(); 
                    }
                }, 20);
            },

            updateMonitor: (fps, handVal) => {
                document.getElementById('disp-fps').innerText = fps + " Hz";
                if(handVal !== null) document.getElementById('disp-val').innerText = handVal.toFixed(2);
            }
        };

        // ================= 1. 输入系统 =================
        function initInput() {
            let isDown = false, lx = 0, ly = 0;
            const move = (x, y) => {
                if(!isDown) return;
                const dx = (x - lx) * 0.005; const dy = (y - ly) * 0.005;
                State.mRotY += dx; State.mRotX += dy; lx = x; ly = y;
            };
            const zoom = (d) => {
                State.mZoom += d * 0.001; State.mZoom = Math.max(0.2, Math.min(3.0, State.mZoom));
            };
            window.addEventListener('mousedown', e => { isDown=true; lx=e.clientX; ly=e.clientY; });
            window.addEventListener('mouseup', () => isDown=false);
            window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
            window.addEventListener('wheel', e => zoom(e.deltaY), {passive:true});
            window.addEventListener('touchstart', e => { if(e.touches.length==1){ isDown=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY; } }, {passive:true});
            window.addEventListener('touchend', () => isDown=false);
            window.addEventListener('touchmove', e => { if(e.touches.length==1) move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:true});
        }
        initInput();

        // ================= 2. 渲染引擎 =================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.015);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 45;
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        function createTex() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');       
            g.addColorStop(0.2, 'rgba(255,240,220,0.6)');   
            g.addColorStop(0.5, 'rgba(255,255,255,0.05)');  
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        const P = { count: 85000, r: 55 };
        let points;
        
        function initGalaxy() {
            const geo = new THREE.BufferGeometry();
            const pos=[], col=[], sz=[];
            const cCore = new THREE.Color(0xffaa00);
            const cMid1 = new THREE.Color(0xff0066);
            const cMid2 = new THREE.Color(0x9900ff);
            const cOut  = new THREE.Color(0x00ccff);

            for(let i=0; i<P.count; i++) {
                const isCore = Math.random() < 0.25;
                let x,y,z, c;
                if(isCore) {
                    const r = Math.pow(Math.random(), 3) * 12;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random()*2 - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = cCore.clone().lerp(new THREE.Color(0xffffff), Math.random()*0.3);
                    sz.push(Math.random()*2.5 + 1.5); 
                } else {
                    const r = Math.random()*P.r + 6;
                    const spin = r * 0.8;
                    const angle = (i % 4)/4 * Math.PI*2;
                    const spread = r * 0.35;
                    const rndX = (Math.random()-0.5)*spread;
                    const rndY = (Math.random()-0.5)*spread*0.6;
                    const rndZ = (Math.random()-0.5)*spread;
                    x = Math.cos(angle+spin)*r + rndX;
                    y = rndY * 2.0;
                    z = Math.sin(angle+spin)*r + rndZ;
                    const ratio = r/P.r;
                    if(ratio < 0.4) c = cMid1.clone().lerp(cMid2, ratio*2.5);
                    else c = cMid2.clone().lerp(cOut, (ratio-0.4)*1.6);
                    sz.push(Math.random()*2);
                }
                pos.push(x,y,z);
                col.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(col,3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));
            
            const mat = new THREE.ShaderMaterial({
                uniforms: { tex: { value: createTex() } },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true, vertexColors: true
            });
            points = new THREE.Points(geo, mat);
            scene.add(points);
        }
        initGalaxy();

        // 渲染循环
        let cRotX=0, cRotY=0, cZoom=1;
        let lastTime = 0;
        let frameCount = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            frameCount++;
            if(time - lastTime >= 1000) {
                UI.updateMonitor(frameCount, null);
                frameCount = 0;
                lastTime = time;
            }

            if(State.hasHand) {
                State.tRotX = State.hRotX; State.tRotY = State.hRotY; State.tZoom = State.hZoom;
                State.mRotX = State.hRotX; State.mRotY = State.hRotY; State.mZoom = State.hZoom;
                points.rotation.y += 0.0002;
            } else {
                State.tRotX = State.mRotX; State.tRotY = State.mRotY; State.tZoom = State.mZoom;
                points.rotation.y += 0.0006;
            }

            cRotX += (State.tRotX - cRotX) * 0.08;
            cRotY += (State.tRotY - cRotY) * 0.08;
            cZoom += (State.tZoom - cZoom) * 0.08;

            const r = 45 * cZoom;
            camera.position.x = r * Math.sin(cRotY) * Math.cos(cRotX);
            camera.position.y = r * Math.sin(cRotX);
            camera.position.z = r * Math.cos(cRotY) * Math.cos(cRotX);
            camera.lookAt(0,0,0);

            renderer.render(scene, camera);
        }
        animate(0);

        // ================= 3. AI 网络 (Safari 修复版) =================
        const Network = {
            sources: [
                { name: '阿里云 CDN', url: 'https://registry.npmmirror.com/@mediapipe/hands/0.4.1646424915/files/' },
                { name: '镜像官方源', url: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' }
            ],

            async init() {
                const elNet = document.getElementById('disp-net');
                const elPing = document.getElementById('disp-ping');

                let bestSrc = this.sources[0];
                let minPing = 9999;
                
                for(let src of this.sources) {
                    const start = performance.now();
                    try {
                        await fetch(src.url + 'hands_solution_packed_assets_loader.js', {method:'HEAD'});
                        const ping = Math.round(performance.now() - start);
                        if(ping < minPing) { minPing = ping; bestSrc = src; }
                    } catch(e) {}
                }

                elNet.innerText = bestSrc.name;
                elPing.innerText = minPing < 9999 ? minPing + " ms" : "超时";

                try {
                    const hands = new Hands({locateFile: f => bestSrc.url + f});
                    hands.setOptions({
                        maxNumHands: 1, modelComplexity: 0, 
                        minDetectionConfidence: 0.4, minTrackingConfidence: 0.4
                    });
                    hands.onResults(this.onRes);

                    const vid = document.getElementById('input_video');
                    // ★★★ Safari 核心修复：移除 width/height 强制约束 ★★★
                    const cam = new Camera(vid, {
                        onFrame: async () => await hands.send({image: vid}),
                        // width: 320,  <-- 已删除，防止 iOS 报错
                        // height: 240, <-- 已删除，防止 iOS 报错
                        facingMode: 'user'
                    });
                    await cam.start();
                } catch(e) {
                    elNet.innerText = "加载失败: " + e.name;
                }
            },

            onRes(res) {
                const elSrc = document.getElementById('disp-source');
                const elVal = document.getElementById('disp-val');
                
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    State.hasHand = true;
                    elSrc.innerText = "AI 手势识别"; // 英文显示
                    elSrc.className = "value accent";

                    const lm = res.multiHandLandmarks[0];
                    const x = (1 - lm[8].x) * 2 - 1;
                    const y = -(lm[8].y * 2 - 1);
                    State.hRotY = x * 2.5; State.hRotX = y * 1.5;

                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    elVal.innerText = d.toFixed(2); 

                    if(d < 0.2) State.hZoom = 0.4;
                    else if(d > 0.35) State.hZoom = 1.8;
                    else State.hZoom = 1.0;
                } else {
                    State.hasHand = false;
                    elSrc.innerText = "TOUCH / MOUSE";
                    elSrc.className = "value inactive";
                }
            }
        };

        window.onload = UI.intro;
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
